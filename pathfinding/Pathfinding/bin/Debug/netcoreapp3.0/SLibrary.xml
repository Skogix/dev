<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>SLibrary</name></assembly>
<members>
<member name="T:SLibrary.RailWay">
<summary>
 generic functions that i want to include in other projects later

</summary>
</member>
<member name="T:Practice.ResultBuilder">
<summary>
 monadic vs applicative
 applicative
   all validations up front and combine results
   pro; didnt lose any validation errors
   con; may do work that we dont need (still validate second when first fail)
 monadic
   chained together
   pro; short circuit when we get an error
   con; only gets the first error message
 computation expressions
 https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/computation-expressions
 let! M&lt;&apos;T&gt; * (&apos;T -&gt; M&lt;&apos;U&gt;) -&gt; M&lt;&apos;U&gt;
 do! unit -&gt; M&lt;&apos;T&gt;
 yield &apos;T -&gt; M&lt;&apos;T&gt;
 yield! M&lt;&apos;T&gt; -&gt; M&lt;&apos;T&gt;
 return &apos;T -&gt; M&lt;&apos;T&gt;
 return! M&lt;&apos;T&gt; -&gt; M&lt;&apos;T&gt;
 match! (let! with pattern match)

 let! binds the result of a call to a name
 let binds the value of an unrealized call
   bind; bind(x ,f)

 do! call a computation expression that return unit
   zero; bind(x, f&lt;*-&gt;unit&gt;)

 yield returns a whole value to ienumerable
   yield(type)
   most often used with -&gt;

 yield! returns a flattened collection one by one
   yieldfrom(type)

 return wraps a value to the expressions type
   return(type)
   let! x = ...
   async return -&gt; x
   // async&lt;x&gt;

 return! realizes the value of the expression
   returnfrom(type)
   return! x
   // async&lt;x&gt;

 match! matches a realized expression
   match! asyncTryGet x with

</summary>
</member>
<member name="P:Practice.example1">
<summary>
 continuation
 let the caller decide, almost like visitor-pattern?

</summary>
</member>
<member name="M:Practice.Bind.optionBind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 like a bind but monadic instead of applicative
 bind, flatMap, andThen, collect, selectMany
 &gt;&gt;= (left to right) =&lt;&lt; (right to left)
 normal to monadic functions
 (a -&gt; X&lt;b&gt;) -&gt; X&lt;a&gt; -&gt; X&lt;B&gt;
</summary>
</member>
<member name="M:Practice.Zip.zipList``2(Microsoft.FSharp.Collections.FSharpList{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Collections.FSharpList{``1},Microsoft.FSharp.Collections.FSharpList{``1}}}},Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 zip,zip3 map2
 &lt;*&gt;
 combine two enumerables with a function
 E&lt;(a-&gt;b-&gt;c)&gt; -&gt; E&lt;a&gt; -&gt; E&lt;b&gt; -&gt; E&lt;c&gt; // when E is enumerable
 E&lt;a&gt; -&gt; E&lt;b&gt; -&gt; E&lt;a,b&gt; // when E is a tuple
</summary>
</member>
<member name="M:Practice.Lift.op_LessMultiplyGreater``2">
<summary>
 lift2, lift2... (lift1 = map)
 combine x lifter values using a function
 lift2: (a-&gt;b-&gt;c) -&gt; X&lt;a&gt; -&gt; X&lt;b&gt; -&gt; X&lt;c&gt;
</summary>
</member>
<member name="M:Practice.Apply.applyOption``2(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Applicative Functor
 apply, ap
 &lt;*&gt;
 unpacks a lifted function from a lifted value to a lifted function
 X&lt;(a-&gt;b&gt; -&gt; X&lt;a&gt; -&gt; X&lt;b&gt;
</summary>
</member>
<member name="M:Practice.Return.returnOption``1(``0)">
<summary>
 return, pure, unit, yield, point
 lifts a single value
 a -&gt; X&lt;a&gt;
</summary>
</member>
<member name="M:Practice.Map.mapOption``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Wrapper type, Monadic type
 map, lift, select
 &lt;$&gt; &lt;!&gt;
 lifts a function
 (a-b) -&gt; X&lt;a&gt; -&gt; X&lt;b&gt;
</summary>
</member>
</members>
</doc>
